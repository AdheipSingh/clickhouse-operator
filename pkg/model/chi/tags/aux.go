// Copyright 2019 Altinity Ltd and/or its affiliates. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tags

import (
	"fmt"

	meta "k8s.io/apimachinery/pkg/apis/meta/v1"
	k8sLabels "k8s.io/apimachinery/pkg/labels"

	api "github.com/altinity/clickhouse-operator/pkg/apis/clickhouse.altinity.com/v1"
	"github.com/altinity/clickhouse-operator/pkg/util"
)

func appendConfigLabels(host *api.Host, labels map[string]string) map[string]string {
	if !host.HasCurStatefulSet() {
		return labels
	}
	// Have CurStatefulSet
	stsLabels := host.Runtime.CurStatefulSet.GetLabels()
	if stsLabels == nil {
		return labels
	}
	// Have labels
	if val, exists := stsLabels[LabelZookeeperConfigVersion]; exists {
		labels[LabelZookeeperConfigVersion] = val
	}
	if val, exists := stsLabels[LabelSettingsConfigVersion]; exists {
		labels[LabelSettingsConfigVersion] = val
	}
	//labels[LabelZookeeperConfigVersion] = host.Config.ZookeeperFingerprint
	//labels[LabelSettingsConfigVersion] = host.Config.SettingsFingerprint
	return labels
}

// GetReclaimPolicy gets reclaim policy from meta
func GetReclaimPolicy(meta meta.Object) api.PVCReclaimPolicy {
	defaultReclaimPolicy := api.PVCReclaimPolicyDelete

	labels := meta.GetLabels()
	if labels == nil {
		return defaultReclaimPolicy
	}

	if value, ok := labels[LabelPVCReclaimPolicyName]; ok {
		reclaimPolicy := api.NewPVCReclaimPolicyFromString(value)
		if reclaimPolicy.IsValid() {
			return reclaimPolicy
		}
	}

	return defaultReclaimPolicy
}

// makeSetFromObjectMeta makes k8sLabels.Set from ObjectMeta
func makeSetFromObjectMeta(meta meta.Object) (k8sLabels.Set, error) {
	// Check mandatory labels are in place
	if !util.MapHasKeys(meta.GetLabels(), LabelNamespace, LabelAppName, LabelCHIName) {
		return nil, fmt.Errorf(
			"UNABLE to make set from object. Need to have at least labels '%s', '%s' and '%s'. Available Labels: %v",
			LabelNamespace, LabelAppName, LabelCHIName, meta.GetLabels(),
		)
	}

	labels := []string{
		// Mandatory labels
		LabelNamespace,
		LabelAppName,
		LabelCHIName,

		// Optional labels
		LabelClusterName,
		LabelShardName,
		LabelReplicaName,
		LabelConfigMap,
		LabelService,
	}

	set := k8sLabels.Set{}
	util.MergeStringMapsOverwrite(set, meta.GetLabels(), labels...)

	// skip StatefulSet
	// skip Zookeeper

	return set, nil
}

// MakeSelectorFromObjectMeta makes selector from meta
// TODO review usage
func MakeSelectorFromObjectMeta(meta meta.Object) (k8sLabels.Selector, error) {
	set, err := makeSetFromObjectMeta(meta)
	if err != nil {
		// Unable to make set
		return nil, err
	}
	return k8sLabels.SelectorFromSet(set), nil
}

// IsCHOPGeneratedObject check whether object is generated by an operator. Check is label-based
func IsCHOPGeneratedObject(meta meta.Object) bool {
	labels := meta.GetLabels()
	if !util.MapHasKeys(labels, LabelAppName) {
		return false
	}
	return labels[LabelAppName] == LabelAppValue
}

// GetCRNameFromObjectMeta extracts CHI name from ObjectMeta. Based on labels.
func GetCRNameFromObjectMeta(meta meta.Object) (string, error) {
	labels := meta.GetLabels()
	if !util.MapHasKeys(labels, LabelCHIName) {
		return "", fmt.Errorf("can not find %s label in meta", LabelCHIName)
	}
	return labels[LabelCHIName], nil
}

// GetClusterNameFromObjectMeta extracts cluster name from ObjectMeta. Based on labels.
func GetClusterNameFromObjectMeta(meta meta.Object) (string, error) {
	labels := meta.GetLabels()
	if !util.MapHasKeys(labels, LabelClusterName) {
		return "", fmt.Errorf("can not find %s label in meta", LabelClusterName)
	}
	return labels[LabelClusterName], nil
}

// MakeObjectVersion makes object version label
func MakeObjectVersion(meta meta.Object, obj interface{}) {
	meta.SetLabels(
		util.MergeStringMapsOverwrite(
			meta.GetLabels(),
			map[string]string{
				LabelObjectVersion: util.Fingerprint(obj),
			},
		),
	)
}

// GetObjectVersion gets version of the object
func GetObjectVersion(meta meta.Object) (string, bool) {
	labels := meta.GetLabels()
	if labels == nil {
		return "", false
	}
	label, ok := labels[LabelObjectVersion]
	return label, ok
}

// appendKeyReady sets "Ready" key to Ready state (used with labels and annotations)
func appendKeyReady(dst map[string]string) map[string]string {
	return util.MergeStringMapsOverwrite(
		dst,
		map[string]string{
			LabelReadyName: LabelReadyValueReady,
		},
	)
}

// deleteKeyReady sets "Ready" key to NotReady state (used with labels and annotations)
func deleteKeyReady(dst map[string]string) map[string]string {
	return util.MergeStringMapsOverwrite(
		dst,
		map[string]string{
			LabelReadyName: LabelReadyValueNotReady,
		},
	)
}

// hasKeyReady checks whether "Ready" key has Ready state (used with labels and annotations)
func hasKeyReady(src map[string]string) bool {
	if _, ok := src[LabelReadyName]; ok {
		return src[LabelReadyName] == LabelReadyValueReady
	}
	return false
}

// AppendLabelReady appends "Ready" label to ObjectMeta.Labels.
// Returns true in case label was not in place and was added.
func AppendLabelReady(meta meta.Object) bool {
	if meta == nil {
		// Nowhere to add to, not added
		return false
	}
	if hasKeyReady(meta.GetLabels()) {
		// Already in place, value not added
		return false
	}
	// Need to add
	meta.SetLabels(appendKeyReady(meta.GetLabels()))
	return true
}

// DeleteLabelReady deletes "Ready" label from ObjectMeta.Labels
// Returns true in case label was in place and was deleted.
func DeleteLabelReady(meta meta.Object) bool {
	if meta == nil {
		// Nowhere to delete from, not deleted
		return false
	}
	if hasKeyReady(meta.GetLabels()) {
		// In place, need to delete
		meta.SetLabels(deleteKeyReady(meta.GetLabels()))
		return true
	}
	// Not available, not deleted
	return false
}

// AppendAnnotationReady appends "Ready" annotation to ObjectMeta.Annotations
// Returns true in case annotation was not in place and was added.
func AppendAnnotationReady(meta meta.Object) bool {
	if meta == nil {
		// Nowhere to add to, not added
		return false
	}
	if hasKeyReady(meta.GetAnnotations()) {
		// Already in place, not added
		return false
	}
	// Need to add
	meta.SetAnnotations(appendKeyReady(meta.GetAnnotations()))
	return true
}

// DeleteAnnotationReady deletes "Ready" annotation from ObjectMeta.Annotations
// Returns true in case annotation was in place and was deleted.
func DeleteAnnotationReady(meta meta.Object) bool {
	if meta == nil {
		// Nowhere to delete from, not deleted
		return false
	}
	if hasKeyReady(meta.GetAnnotations()) {
		// In place, need to delete
		meta.SetAnnotations(deleteKeyReady(meta.GetAnnotations()))
		return true
	}
	// Not available, not deleted
	return false
}
